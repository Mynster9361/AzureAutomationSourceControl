name: Sync Azure Automation Runbooks

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:

permissions:
  contents: read

jobs:
  sync-runbooks:
    runs-on: ubuntu-latest

    permissions:
      id-token: write
      contents: read

    steps:
    - name: Checkout repository
      uses: actions/checkout@v5
      with:
        fetch-depth: 0  # Important to fetch all history for proper diffs

    - name: Get changed files
      id: changed-files
      run: |
        # Different approach based on event type
        if [[ "${{ github.event_name }}" == "pull_request" ]]; then
          # For pull requests, compare base and head commits
          echo "Getting changes from PR"
          DIFF_OUTPUT=$(git diff --name-status ${{ github.event.pull_request.base.sha }} ${{ github.event.pull_request.head.sha }})
        elif [[ "${{ github.event_name }}" == "push" ]]; then
          # For pushes, compare previous and current commits
          echo "Getting changes from push"
          if [[ -n "${{ github.event.before }}" && "${{ github.event.before }}" != "0000000000000000000000000000000000000000" ]]; then
            DIFF_OUTPUT=$(git diff --name-status ${{ github.event.before }} ${{ github.sha }})
          else
            # First push to branch case - compare with the first parent commit
            echo "First push to branch, getting all files"
            DIFF_OUTPUT=$(git diff --name-status $(git rev-parse HEAD^) ${{ github.sha }})
          fi
        else
          # For workflow_dispatch or other events, list all files
          echo "Manual workflow run, getting all files"
          DIFF_OUTPUT=$(find . -type f -not -path "*/\.*" -not -path "*/node_modules/*" | sed 's/^\.\//A /')
        fi

        echo "Changes detected:"
        echo "$DIFF_OUTPUT"

        # Create separate files for added/modified and deleted files
        ADDED_MODIFIED_FILES=""
        DELETED_FILES=""

        # Process each line individually to handle all cases, including renames
        while IFS= read -r line; do
          if [[ -z "$line" ]]; then
            continue  # Skip empty lines
          fi

          status=${line:0:1}  # Get first character (status code)

          if [[ "$status" == "A" || "$status" == "M" ]]; then
            # Added or modified file
            file=$(echo "$line" | awk '{print $2}')
            ADDED_MODIFIED_FILES+="$file "
          elif [[ "$status" == "D" ]]; then
            # Deleted file
            file=$(echo "$line" | awk '{print $2}')
            DELETED_FILES+="$file "
          elif [[ "$status" == "R" ]]; then
            # Renamed file - treat as both deletion and addition
            old_file=$(echo "$line" | awk '{print $2}')
            new_file=$(echo "$line" | awk '{print $3}')
            DELETED_FILES+="$old_file "
            ADDED_MODIFIED_FILES+="$new_file "
          fi
        done <<< "$DIFF_OUTPUT"

        # Trim trailing spaces
        ADDED_MODIFIED_FILES=$(echo "$ADDED_MODIFIED_FILES" | xargs)
        DELETED_FILES=$(echo "$DELETED_FILES" | xargs)

        # Set environment variables
        echo "ADDED_MODIFIED_FILES=$ADDED_MODIFIED_FILES" >> $GITHUB_ENV
        echo "DELETED_FILES=$DELETED_FILES" >> $GITHUB_ENV

        echo "Processed changes:"
        echo "Added/Modified: $ADDED_MODIFIED_FILES"
        echo "Deleted: $DELETED_FILES"

    - name: Display changed files
      run: |
        echo "Added or Modified files:"
        echo "$ADDED_MODIFIED_FILES"
        echo "----------------------"
        echo "Deleted files:"
        echo "$DELETED_FILES"

    - name: Azure Login
      uses: azure/login@v2
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}


    - name: Sync Azure Automation Runbooks
      shell: pwsh
      run: |
        $subscriptionId = "${{ secrets.AZURE_SUBSCRIPTION_ID }}"
        $resourceGroup = "${{ secrets.AZURE_RESOURCE_GROUP }}"
        $automationAccount = "${{ secrets.AZURE_AUTOMATION_ACCOUNT }}"
        $addedModifiedFiles = "${{ env.ADDED_MODIFIED_FILES }}"
        $deletedFiles = "${{ env.DELETED_FILES }}"
        $token = (az account get-access-token --query accessToken -o tsv)

        $headers = @{
          Authorization = "Bearer $token"
          "Content-Type" = "application/json"
        }
        $baseUrl = "https://management.azure.com"
        $apiVersion = "2024-10-23"

        $getAutomationAccountUrl = "$baseUrl/subscriptions/$subscriptionId/resourceGroups/$resourceGroup/providers/Microsoft.Automation/automationAccounts/$automationAccount?api-version=$apiVersion"
        # Verify that the Automation Account exists
        try {
          $automationAccountResponse = Invoke-RestMethod -Uri $getAutomationAccountUrl -Method Get -Headers $headers
          Write-Host "Automation Account '$automationAccount' found in resource group '$resourceGroup'."
        } catch {
          Write-Error "Failed to find Automation Account '$automationAccount' in resource group '$resourceGroup'. Please check your configuration."
          exit 1
        }

        # Used to get a list of existing runbooks
        $listUrl = "$baseUrl/subscriptions/$subscriptionId/resourceGroups/$resourceGroup/providers/Microsoft.Automation/automationAccounts/$automationAccount/runbooks?api-version=$apiVersion"

        $createModifyUrl = "$baseUrl/subscriptions/$subscriptionId/resourceGroups/$resourceGroup/providers/Microsoft.Automation/automationAccounts/$automationAccount/runbooks/{0}?api-version=$apiVersion"
        $deleteUrl = "$baseUrl/subscriptions/$subscriptionId/resourceGroups/$resourceGroup/providers/Microsoft.Automation/automationAccounts/$automationAccount/runbooks/{0}?api-version=$apiVersion"

        # list of existing runbooks in the automation account
        # This step is needed in order to retain tags set on existing runbooks
        [System.Collections.Generic.List[System.Object]] $existingRunbooks = @()
        $listResponse = Invoke-RestMethod -Uri $listUrl -Method Get -Headers $headers
        $existingRunbooks.addRange($listResponse.value)
        do {
          $listResponse = Invoke-RestMethod -Uri $listResponse.nextLink -Method Get -Headers $headers
          $existingRunbooks.addRange($listResponse.value)
        } until ($null -eq $listResponse.nextLink)

        # Process added or modified files
        if (-not [string]::IsNullOrWhiteSpace($addedModifiedFiles)) {
          $addedModifiedFiles.Split(" ") | ForEach-Object {
            $filePath = $_.Trim()
            if (-not [string]::IsNullOrWhiteSpace($filePath) -and (Test-Path $filePath)) {
              $runbookName = [System.IO.Path]::GetFileNameWithoutExtension($filePath)
              $runbookType = "PowerShell"
              if ($filePath -like "*.ps1") {
                $runbookType = "PowerShell"
              } elseif ($filePath -like "*.py") {
                $runbookType = "Python2"
              } elseif ($filePath -like "*.py3") {
                $runbookType = "Python3"
              } else {
                Write-Warning "Unsupported file type for $filePath. Skipping."
                return
              }
              $content = Get-Content -Path $filePath -Raw
              $existingRunbook = $existingRunbooks | Where-Object { $_.name -eq $runbookName }
              if ($null -ne $existingRunbook) {
                Write-Host "Modifying existing runbook: $runbookName"
                $url = [string]::Format($createModifyUrl, $runbookName)
                $body = @{
                  location = $automationAccountResponse.location
                  tags = $existingRunbook.tags
                  properties = @{
                    runbookType = $runbookType
                    draft = @{
                      inEdit = $false
                      draftContent = $content
                    }
                  }
                } | ConvertTo-Json -Depth 10
                Invoke-RestMethod -Uri $url -Method Put -Headers $headers -Body $body
              } else {
                Write-Host "Creating new runbook: $runbookName"
                $url = [string]::Format($createModifyUrl)
                $body = @{
                  location = $automationAccountResponse.location
                  name = $runbookName
                  properties = @{
                    runbookType = $runbookType
                    draft = @{
                      inEdit = $false
                      draftContent = $content
                    }
                  }
                } | ConvertTo-Json -Depth 10
                Invoke-RestMethod -Uri $url -Method Put -Headers $headers -Body $body
              }
            } else {
              Write-Warning "File $filePath does not exist. Skipping."
            }
          }
        } else {
          Write-Host "No added or modified files to process."
        }
        # Process deleted files
        if (-not [string]::IsNullOrWhiteSpace($deletedFiles)) {
          $deletedFiles.Split(" ") | ForEach-Object {
            $filePath = $_.Trim()
            if (-not [string]::IsNullOrWhiteSpace($filePath)) {
              $runbookName = [System.IO.Path]::GetFileNameWithoutExtension($filePath)
              $existingRunbook = $existingRunbooks | Where-Object { $_.name -eq $runbookName }
              if ($null -ne $existingRunbook) {
                Write-Host "Deleting runbook: $runbookName"
                $url = [string]::Format($deleteUrl, $runbookName)
                Invoke-RestMethod -Uri $url -Method Delete -Headers $headers
              } else {
                Write-Warning "Runbook $runbookName does not exist in Azure Automation. Skipping deletion."
              }
            } else {
              Write-Warning "Invalid file path for deletion. Skipping."
            }
          }
        } else {
          Write-Host "No deleted files to process."
        }

